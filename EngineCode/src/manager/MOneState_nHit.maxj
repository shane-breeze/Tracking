package manager;

import kernel.KOneState_nHit;
import misc.Misc;

import com.maxeler.maxcompiler.v2.build.EngineParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFETypeFactory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType.StructFieldType;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import formats.TrackingRecHit;
import formats.TrajectoryState;

public class MOneState_nHit extends CustomManager{

	public static void main(String[] args){
		EngineParameters params = new EngineParameters();
		MOneState_nHit m = new MOneState_nHit(params);
		m.createSLiCinterface(interfaceDefault());
		m.build();
	}

	public MOneState_nHit(EngineParameters params){
		super(params);

		this.getCurrentKernelConfig().debug.setEnableLatencyAnnotation(true);
		KernelBlock updator = addKernel(new KOneState_nHit(makeKernelParameters("KFUpdator")));

		DFELink inHit = addStreamFromCPU("hit");
		DFELink inState = addStreamFromCPU("state");
		DFELink inStateControl = addStreamFromCPU("stateControl");
		DFELink out = addStreamToCPU("state_up");

		updator.getInput("hit") <== inHit;
		updator.getInput("state") <== inState;
		updator.getInput("nHits") <== inStateControl;
		out <== updator.getOutput("state_up");
	}

    private static EngineInterface interfaceDefault(){
        EngineInterface ei = new EngineInterface();
        InterfaceParam n = ei.addParam("nHits",CPUTypes.INT32); // Number of hits
        InterfaceParam m = ei.addParam("nStates", CPUTypes.INT32); // Number of states
        // Note: the state is wide enough for a PCIE transaction, but state control is not
        // In principal nControls = m, but sometimes needs rounding up to next PCIE transaction size
        InterfaceParam nControls = ei.addParam("nStateControls", CPUTypes.INT32); // Number of state controls

        DFEType T = DFETypeFactory.dfeFloat(8, 24);

		StructFieldType sftTrajectory = new StructFieldType("trajectoryState", TrajectoryState.ioType(T, 5));
		StructFieldType sftEOF = new StructFieldType("EOF", T);
		DFEStructType tTrajectory = Misc.addPCIEPadding(new StructFieldType[]{sftTrajectory, sftEOF}).data();
		int nStateIn = tTrajectory.getTotalBytes();

		int nStateOut = TrajectoryState.ioType(T, 5).getTotalBytes();

		StructFieldType sftHit = new StructFieldType("hit", TrackingRecHit.ioType(T, 2));
		DFEStructType tHit = Misc.addPCIEPadding(new StructFieldType[]{sftHit}).data();
		int nHit = tHit.getTotalBytes();

		ei.setTicks("KFUpdator", n);
        ei.setStream("state", CPUTypes.FLOAT, nStateIn * m);
        ei.setStream("nHits", CPUTypes.UINT32, CPUTypes.UINT32.sizeInBytes() * nControls);
        ei.setStream("hit", CPUTypes.FLOAT, nHit * n);
        ei.setStream("state_up", CPUTypes.FLOAT, nStateOut * n);
        ei.setScalar("KFUpdator", "nStates", m);
        ei.setScalar("KFUpdator", "nStateRepeats", nControls);
        return ei;
    }
}
