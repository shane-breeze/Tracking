package kernel;

import kalman.KFUpdator;
import kalman.ProjectMatrix;
import matrix.SymMatrix;
import matrix.Vector;
import misc.Misc;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Params;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Queue;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFETypeFactory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType.StructFieldType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;

import formats.TrackingRecHit;
import formats.TrajectoryState;

public class KOneState_nHit extends Kernel{

	public static DFEType T = DFETypeFactory.dfeFloat(8, 24);
	public static int D = 2;
	public static int N = 5;

	public KOneState_nHit(KernelParameters params){
		super(params);
		ProjectMatrix pf = new ProjectMatrix(new int[]{3, 4}, D, N); // Projection matrix H

		// Input the hit
		StructFieldType sftHit = new StructFieldType("hit", TrackingRecHit.ioType(T, D));
		DFEStructType tHit = Misc.addPCIEPadding(new StructFieldType[]{sftHit}).data();
		DFEStruct inHitData = io.input("hit", tHit);

		// Make a type for the trajectory
		StructFieldType sftTrajectory = new StructFieldType("trajectoryState", TrajectoryState.ioType(T, N));
		//StructFieldType sftEOF = new StructFieldType("nextPosition", T);
		DFEStructType tTrajectory = Misc.addPCIEPadding(new StructFieldType[]{sftTrajectory}).data();

		// Counter for number of hits read for current state
		DFEVar nHitsPerState = dfeUInt(32).newInstance(this);
		Params countParams = control.count.makeParams(32).withMax(nHitsPerState);
		Counter hitCount = control.count.makeCounter(countParams);

		// Run cycle counter
		Counter runCycleCounter = control.count.makeCounter(control.count.makeParams(16));
		DFEVar clkCount = runCycleCounter.getCount();

		// Counter for the number of counter wrap signals
		// Need to ignore the first 'ioLatency' input reads, since this many are already buffered
		int iLatency = 6;
		Counter nReadsCounter = control.count.makeCounter(control.count.makeParams(16).withEnable(hitCount.getWrap()));

		DFEVar preIOLatency = clkCount < iLatency;//io.getInputNode("nHits").getLatency();
		//DFEVar iStateEnable = preLoopLatency ? constant.var(true) :
		//DFEVar iStateWEnable = clkCount === 1;
		optimization.pushNoPipelining();
		DFEVar iStateWEnableHold = (hitCount.getWrap() & (nReadsCounter.getCount() >= iLatency)) | preIOLatency;
		optimization.popNoPipelining();

		DFEVar iStateWEnable = Reductions.streamHold(iStateWEnableHold, constant.var(true), dfeBool().encodeConstant(true));
		debug.simPrintf("iStateWEnable: %d", iStateWEnable);
		//DFEVar iStateWEnable = clkCount === 1;
		//iStateWEnable = iStateWEnable.unscheduled();

		DFEVar iStateREnable = Reductions.streamHold(hitCount.getWrap(), constant.var(true), dfeBool().encodeConstant(true));
		iStateREnable = iStateREnable.unscheduled();
		// Input the state
		DFEStruct inTrajectoryData = io.input("state", tTrajectory, stream.offset(iStateWEnable, -7, dfeBool().encodeConstant(true)));
		// Input the state repeat: the number of hits to filter with this state
		//DFEVar nHits = io.input("nHits", dfeUInt(32), iStateEnable);
		DFEVar inNHitsPerState = io.input("nHits", dfeUInt(32), stream.offset(iStateWEnable, -7, dfeBool().encodeConstant(true)));

		// Put the state and nHits into a FIFO, for the processing latency of the io logic
		StructFieldType sftNHits = new StructFieldType("nHits", dfeUInt(32));
		DFEStructType tQData = new DFEStructType(sftTrajectory, sftNHits);
		DFEStruct qiData = tQData.newInstance(this);
		//DFEStruct qiData = TrajectoryState.ioType(T, N).newInstance(this);
		qiData.get("trajectoryState") <== inTrajectoryData.get("trajectoryState");
		qiData.get("nHits") <== inNHitsPerState;

		int lStateInput = io.getInputNode("state").getLatency();
		Queue<DFEStruct> iQueue = mem.queue(tQData, 32);

		iQueue.insert(stream.offset(qiData, -2), stream.offset(iStateWEnable, -4));
		DFEStruct qoData = iQueue.remove(iStateREnable);//stream.offset(iStateREnable, -4));
		nHitsPerState <== (DFEVar) qoData.get("nHits");
		//Params countParams = control.count.makeParams(32).withMax(nHitsPerState);
		//runCycleCount = control.count.makeCounter(countParams);

		//iStateEnable <== stream.offset(Reductions.streamHold(runCycleCount.getWrap(), constant.var(true), dfeBool().encodeConstant(true)), -1);
		//iStateEnable = iStateEnable.unscheduled(); // I think

		//NonBlockingInput<DFEStruct> ioTrajectory = io.nonBlockingInput("state", tTrajectory, TrajectoryState.ioType(T, N).getTotalBits() + 1);
		//DFEStruct inTrajectoryData = Reductions.streamHold(ioTrajectory.data, ioTrajectory.valid);

		// Repackage the trajectory
		DFEStruct tsData = qoData.get("trajectoryState");//(DFEStruct) inTrajectoryData.get("trajectoryState");
		DFEVector<DFEVar> xData = (DFEVector<DFEVar>) tsData.get(TrajectoryState.label.X.label());
		DFEVector<DFEVar> cData = (DFEVector<DFEVar>) tsData.get(TrajectoryState.label.C.label());;
		Vector x = new Vector(xData);
		SymMatrix<DFEVar> C = new SymMatrix<DFEVar>(this, cData.packToList());
		TrajectoryState ts = new TrajectoryState(x, C);

		//Repackage the hit
		DFEStruct hitData = (DFEStruct) inHitData.get("hit");
		TrackingRecHit hit = new TrackingRecHit(hitData);
		KFUpdator updator = new KFUpdator(this);

		// Do the update
		TrajectoryState ts_up = updator.update(ts, hit, pf);

		DFEStruct outData = ts_up.packForIO();
		io.output("state_up", outData, ts_up.ioType());

		((DFEStruct) inTrajectoryData.get("trajectoryState")).get(TrajectoryState.label.X.label()).simWatch("X_in");
		xData.simWatch("X_QO");
		//cData.simWatch("C");
		hit.pos().watch("hit_pos");
		nHitsPerState.simWatch("nHitsPerState_QO");
		hitCount.getCount().simWatch("hitCount");
		iStateWEnable.simWatch("iStateWEnable");
		iStateREnable.simWatch("iStateREnable");
		stream.offset(iStateREnable, -4).simWatch("iStateREnable_off4");
		iQueue.valid().simWatch("Q_valid");
	}
}
